<!--
Ciclo di vita di un componente:
ngOnInit(), ngAfterContentInit(), ngAfterViewInit(), sono chiamate solo una volta
--------------------------------------------------------------------------------------------------------------------------------
ngOnChanges() chiama ngDoCheck(), ngAfterContentChecked(), ngAfterViewChecked(), ngOnDestroy() ad ogni chiamata successiva
--------------------------------------------------------------------------------------------------------------------------------

Data binding: one-way binding (string interpolation, property binding, event binding), two-way binding
Capacità di modificare gli elementi di un componente in maniera dinamica

--------------------------------------------------------------------------------------------------------------------------------
string interpolation e property binding mandano qualcosa dal ts all'html (model to view)
event binding manda dalla view al model (che poi andrà dopo a far cose)
--------------------------------------------------------------------------------------------------------------------------------
string interpolation (interpolazioni dinamiche): {{ funzioni, valori, ternary operator, ... }};
property binding: [modifica di una proprietà nell'html];
event binding: ($event: viene generata quando avviene l'evento)
--------------------------------------------------------------------------------------------------------------------------------
two-way binding: modifica simultanea di model e view [(ngModel)] <- modifica sia di property che di event
--------------------------------------------------------------------------------------------------------------------------------

Directives: classi che aggiungono comportamenti agli elementi: built-in, attribute (personalizzate), structural

--------------------------------------------------------------------------------------------------------------------------------
structural: (*ngIf, *ngFor, ngSwitch) modifica DOM, aggiunge o rimuove elementi HTML
built-in: (ngClass, ngStyle (modifica css), ngModel) modifica del comportamento
attribute: modifica comportamento o apparenza elemento
--------------------------------------------------------------------------------------------------------------------------------
ng-template: Span (wrapper) di angular
<ng-template *ngIf="isVisible then bloccoTrue else bloccoFalse"></ng-template>
<ng-template #bloccoTrue>
    <p>Visible</p>
</ng-template>
<ng-template #bloccoFalse>
    <p>Not visible</p>
</ng-template>
--------------------------------------------------------------------------------------------------------------------------------
*ngFor = "let qualcosa of qualcose; index as i, count as c, first as isFirst, last as isLast, even as isEven, odd as isOdd, ..."
indice parte da 0, count: lunghezza lista, ...
--------------------------------------------------------------------------------------------------------------------------------
<div [ngSwitch]="valore">
    <p *ngSwitchCase="1">1</p>
    <p *ngSwitchCase="2">2</p>
    <p *ngSwitchCase="3">3</p>
    <p *ngSwitchCase="4">4</p>
    <p *ngSwitchDefault>default</p>
</div>
Con le stringhe c'è bisogno delle ''
--------------------------------------------------------------------------------------------------------------------------------
<... [ngStyle] = "{'margin-bottom': valore.funzione ? valoreTrue : valoreFalse}">...
Va a modificare il bg in base a delle condizioni, va bene anche usare il camelCase invece delle '': marginBottom
--------------------------------------------------------------------------------------------------------------------------------
[ngClass] = "{'nuovaClasse nuovaClasse2': possibile.condizione, 'nuovaClasse3'}" modifica della/e classi css dinamiche
Con ternary operator: ..."possibile.condizione ? 'nuovaClasseTrue' : 'nuovaClasseFalse'"...
Con assegnazioni: ...'nuovaClasse': valore.color == 'blue'...
--------------------------------------------------------------------------------------------------------------------------------

Passaggio da parent a child e viceversa

--------------------------------------------------------------------------------------------------------------------------------
Da parent a child: @Input() nomeInput: any; <- da inserire nel figlio
Una volta fatto ciò inseriamo nell'html del padre:
<div>
  <app-figlio [nomeInput]="valoreDaOttenereDalPadre"></app-test>
</div>
In tal maniera possiamo richiamare nel componente figlio valoreDaOttenereDalPadre tramite il property binding.
--------------------------------------------------------------------------------------------------------------------------------
Da child a parent: @Output() nomeOutput: new EventEmitter<tipologiaDiDato>(); <- da inserire nel figlio
Bisognerà poi creare una funzione che emetterà nomeOutput:
mandaDati(){
    this.nomeOutput.emit(this.valoreOpzionale)
}
Una volta fatto ciò inseriamo nell'html del padre:
<div>
  <app-figlio (nomeOutput)="funzioneDaCreareNelPadre($event)"></app-test>
</div>
Successivamente creiamo la funzione nel padre correlata:
funzioneDaCreareNelPadre(value: tipoDiDato){
    ...
}
In tal maniera mandiamo al componente padre nomeOutput tramite event binding.
--------------------------------------------------------------------------------------------------------------------------------
Variabili template: @ViewChild('nomeNellaView'), decoratore che ci indica la presenza di un figlio nella view.
Da inserire nel ts del componente:
@ViewChild('nomeNellaView') nome!: ElementRef<valoreOpzionale>
! indica l'impossibilità di essere null, cosa richiesta da ElementRef
Tale valore sarà ottenibile solo dopo la ngAfterViewInit.
Per ottenerlo: this.nomeDellaView.nativeElement.value
Possibili introduzioni nell'html del componente stesso:
<input #nomeNellaView value="nomeValore">
<button (click)="onClick()"></button>, dove onClick(){ console.log(this.nomeNellaView.nativeElement.value) }
--------------------------------------------------------------------------------------------------------------------------------

Custom Directives

--------------------------------------------------------------------------------------------------------------------------------
{{{Aggiungere secondarie proprietà (raro), passare dati alla direttiva (comune)}}} To Do
ng g d [nomeDirettiva] <- per creare una direttiva custom (meglio posizionarla in una cartella apposita dentro app)
Esempio per cambio bg, direttiva semplice (ordinario)
constructor(private element: ElementRef) {
    
}
Attende un'azione, è di javascript
@HostListener('mouseenter') onMouseEnter(){
    this.changeColor('coloreScelto')
}

@HostListener('mouseenter') onMouseEnter(){
    this.changeColor('altroColoreScelto')
}

changeColor(color: string) {
    this.element.nativeElement.style.backgroundColor = color
}
--------------------------------------------------------------------------------------------------------------------------------

Pipes

--------------------------------------------------------------------------------------------------------------------------------
Funzioni che possiamo utilizzare all'interno delle espressioni string
Es: <p> Testo a {{caso | uppercase}}</p> -> Caso sarà stampato in uppercase
<p>{{numero | number: '1.0-4'}}</p> -> Mostrerà 1 numero dopo la virgola e minimo 0 e massimo 4 numeri dopo la virgola
--------------------------------------------------------------------------------------------------------------------------------

Services

--------------------------------------------------------------------------------------------------------------------------------
Permettono la comunicazione con ogni componente trasversalmente. I dati importanti non dovrebbero essere salvati nei componenti.
I componenti dovrebbero anche possedere poca logica, l'obiettivo ultimo del componente è mandare a schermo roba.
providedIn: 'root' -> vuol dire che chiunque può richiamare questo servizio.
Il nome della classe verrà poi aggiunta ai costruttori dei componenti, in forma privata, per ottenere i dati nel servizio.




-->
<app-home></app-home>

<p class="text-white">test works!</p>